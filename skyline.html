<!DOCTYPE html>
<html>

<style>

hr {
	width: 100px;
	margin-left: 0px;
	background-color: green;
}
</style>

<body>

<strong>Skyline problem</strong>
<br>
Please note: input verification is NOT extensive, so please follow the correct format of (start, end, height) with non-negative integers.
<br><br>

	Enter a point:<br>
	<input type='text' placeholder='(start,end,height)' id='newPoint' onkeydown='if (event.keyCode == 13) makeBuilding(this.value)'>
	<input type='submit' value='Submit' onclick='makeBuilding(document.getElementById("newPoint").value)'>

<br><br>

All points:

<br>

<table id='pointTable'>
	<tr id='pointTableRow'>
	</tr>
</table>


<br><br><br>

<button onClick='initCalcSkyline()'>Calculate Skyline</button>
<button onClick='displayGraph()'>Display graph</button>
<div id='graph'>
	Display here
</div>





<script>

	var rawPointList = [];
	var rawPoint = function(coordinates) { //parse point from HTML into structure
		this.start = coordinates.substring(1,coordinates.indexOf(','));
		coordinates = coordinates.substring(coordinates.indexOf(',')+1);
		this.end = coordinates.substring(0,coordinates.indexOf(','));
		coordinates = coordinates.substring(coordinates.indexOf(',')+1);
		this.height = coordinates.substring(0, coordinates.indexOf(')'));
	}

	//var critPointList = [];
	var criticalPoint = function(x,y) {
		this.x = x;
		this.y = y;
	}


	//receive new point from HTML; parse and store
	function makeBuilding(newBuildingDimensions) {

		if(newBuildingDimensions == '' || newBuildingDimensions.length < 7) return;


		var argsPoint = new rawPoint(newBuildingDimensions);
		rawPointList.push(argsPoint);

		//add to table for visibility
		var newTableItem = document.createElement('td');
		newTableItem.innerHTML = newBuildingDimensions;
		document.getElementById('pointTableRow').appendChild(newTableItem); //add new item to row

		document.getElementById('pointTable').border = 1; //make lines visible after first item
		document.getElementById('newPoint').value = ''; //reset input form
	}


//*************DIVIDE AND CONQUER************************

	//begins recursive skyline calculation with given points
	function initCalcSkyline() {
		document.getElementById('graph').innerHTML = '';

		var critPointList = [];
		//convert all raw points to critical points
		for (var i = 0; i < rawPointList.length; i++) {
			var leftCrit = new criticalPoint(rawPointList[i].start, rawPointList[i].height);
			var rightCrit = new criticalPoint(rawPointList[i].end, 0);
			critPointList.push(leftCrit);
			critPointList.push(rightCrit);
		}

		//sort list by start value
		critPointList.sort(function(a,b) {
			if (a.start > b.start) return 1;
			if (a.start < b.start) return -1;
			return 0;
		});

		for(var j = 0; j < critPointList.length; j++) {
			alert(critPointList[j].x);
		}


		/*
		rawPointList.sort(function(a,b) {
			if (a.start > b.start) return 1;
			if (a.start < b.start) return -1;
			return 0;
		});

		//convert all raw points to critical points
		for(var i = 0; i < rawPointList.length; i++) {
			var leftCrit = new criticalPoint(list1[i].start, list1[i].height);
			var rightCrit = new criticalPoint(list1[i].end, 0);
			list1Crit.push(leftCrit);
			list1Crit.push(rightCrit);
		}
		*/


		var result = calculateSkylineRecursive(critPointList);
		//result is merged skyline
		alert('done ' + result.length);
	}

	//recursive function where divide and conquer takes place
	function calculateSkylineRecursive(curPointList) {
		if(curPointList.length < 2) return curPointList;

		else {
			//split in half and recursively call
			var halfIndex = curPointList.length / 2; //half rounded down
			var firstHalfList = curPointList.slice(0,halfIndex);
			var secondHalfList = curPointList.slice(halfIndex);

			//sort lists by start

			var result = mergeSkylines(calculateSkylineRecursive(firstHalfList), calculateSkylineRecursive(secondHalfList));
			return result; //result should be merged skyline
		}


	}


	//merge function
	function mergeSkylines(list1, list2) {
//		document.getElementById('graph').innerHTML += 'running merge ' + list1.concat(list2) + '<br>';//list1 + list2;

		var resultList = [];
		var list1Crit = [];
		var list2Crit = [];
		var currentHeight = 0;
		var currentx = 0;

// convert to critical points
/*
		for(var i = 0; i < list1.length; i++) {
			var leftCrit = new criticalPoint(list1[i].start, list1[i].height);
			var rightCrit = new criticalPoint(list1[i].end, 0);
			list1Crit.push(leftCrit);
			list1Crit.push(rightCrit);
		}

		for(var j = 0; j < list2.length; j++) {
			var leftCrit = new criticalPoint(list2[j].start, list2[j].height);
			var rightCrit = new criticalPoint(list2[j].end, 0);
			list2Crit.push(leftCrit);
			list2Crit.push(rightCrit);
		}
		*/

//add next value (by x) to result list
		for(var i = 0; i < Math.min(list1Crit.length, list2Crit.length); i++) {
			
			if (list1Crit[i].x < list2Crit[i].x) {
				//list1 item is next
				resultList.push(list1Crit[i]);
				list1Crit.splice(i,1);
			}

			else if (list1Crit[i].x > list2Crit[i].x) {
				//list2 item is next
				resultList.push(list2Crit[i]);
				list2Crit.splice(i,1);
			}

			else { //next critical point has same x
				//take only max of 2 points

				if (list1Crit[i].y > list2Crit[i].y) {
					resultList.push(list1Crit);
				}
				else resultList.push(list2Crit);
				
				list1Crit.splice(i,1);
				list2Crit.splice(i,1);

			}

			//var nextPoint = Math.min(list1Crit[i], list2Crit[i]);


			/*if(list1[i].start > list2[i].start) {
				alert('list 1 is greater');
			}
			else if (list1[i].start < list2[i].start) {
				alert('list 2 is greater');
			}
			else {
				alert('lists are equal');
			}*/
		}

		return (resultList); 
	}


//*************END DIVIDE AND CONQUER********************


	//Display skyline in HTML
	function displayGraph() {
		var newBuilding = document.createElement('hr');
		newBuilding.size=100; //equal to height
		//use style to change width (end - start) and align-left (start)
		//ex: <hr size='500' style='margin-left:50px'>
		document.getElementById('graph').appendChild(newBuilding);
	}

</script>

</body>
</html>